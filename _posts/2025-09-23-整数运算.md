---
title: "整数运算"
date: 2025-09-23  # 文章发布时间
categories: [计算机组织与结构] # 你的分类
tags: [笔记]     # 你的标签
math: true
---



## 算术逻辑单元ALU

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250924200502981.png" alt="image-20250924200502981" style="zoom:50%;" />

 算术逻辑单元(ALU) 是计算机实际完成数据算术逻辑运算的部件

数据由寄存器(Registers) 提交给ALU，运算结果也存于寄存器

ALU可能根据运算结果设置一些标志(Flags)，标志值也保存在处理器内的寄存器中

控制器(Control unit) 提供控制ALU操作和数据传入送出ALU的信号

## 全加器

三个输入，两个输出

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250924200512352.png" alt="image-20250924200512352" style="zoom:50%;" />

计算方法：

$$S_i = X_i ⊕Y_i ⊕C_{i-1}$$

$$C_i = X_iY_i~ + X_iC_{i-1} +Y_iC_{i-1} $$

> [!NOTE]
>
> 与门延迟：1级门延迟(1ty) 
>
> 或门延迟：1级门延迟(1ty) 
>
> 异或门延迟：3级门延迟(3ty）
>
> <img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250924200522683.png" alt="image-20250924200522683" style="zoom:50%;" />
>
> 注意：下一级X和Y的异或运算可以在上一级还没结束时就开始进行！

可是，64位的电脑比32位的在进行加法时会慢一倍！这是不可容忍的！

### 全先行进位加法器

把所有的$$C_i$$先行求出来，这样就不会有那么高的延迟了

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250924200534910.png" alt="image-20250924200534910" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250924200544739.png" alt="image-20250924200544739" style="zoom:50%;" />

缺点：复杂

### 部分先行进位加法器

 采用多个CLA并将其串联，取得计算时间和硬件复杂度之间的权衡

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925140845185.png" alt="image-20250925140845185" style="zoom:50%;" />

- 8n位加法，串联n个8-bit的CLA
- 第一个计算出给下一个的C8需要：1+2=3 ty，Si不与后续元件相关，时间忽略
- 此后每一个的Gi,Pi都预先算好，计算出给下一个的C8i需要2 ty
- 最后一个计算出C8n需要2 ty，S8n需要3 ty
- 因此共需2n+4 ty
- 例如32位就是12 ty

> 此部分引用来源：南软佛脚玩乐指南

## 加法

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925143131926.png" alt="image-20250925143131926" style="zoom:50%;" />

## 减法

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925143210237.png" alt="image-20250925143210237" style="zoom: 50%;" />

将Y进行非运算，再搞一个“1”进来，不就完成了减法操作吗？！

那么“1”怎么搞进来呢？---那个看似毫无存在感的C~0~！将它设置成1就可以了！

## 乘法

### 无符号数：

31次的32位相加！

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925144805972.png" alt="image-20250925144805972" style="zoom:67%;" />

如果是0，直接右移；如果是1，加上被乘数再右移

### 补码：

两个数的和的补码＝两个数的补码的和，但是对于乘法不适用，可以试试(-7)*(-6)

#### 布斯算法

布斯算法要解决的核心问题是**“有符号数”（包括正数和负数）的统一、高效乘法问题**

1. 增加Y~0~= 0
 2. 根据Y~i+1~Y~i~， 决定是否增加+X, -X, +0
 3. 右移部分积
4. 重复步骤2和步骤3共n 次，得到最终结果

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925151259896.png" alt="image-20250925151259896" style="zoom:50%;" />

使用布斯算法右移的时候，为什么会算错？`(-7)*(-6)`会算成106！

因为诸如`1101`右移不应该变成`0100`，而是`1100`！哪有负数右移变成正数的！

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925151833747.png" alt="image-20250925151833747" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925151955348.png" alt="image-20250925151955348" style="zoom:50%;" />

> 个人认为更简单的操作步骤：
>
> 1. **A 寄存器（被乘数寄存器）**：存放被乘数（Multiplicand）。
> 2. **Q 寄存器（乘数寄存器）**：初始时存放乘数（Multiplier）。
> 3. **Q₋₁ 寄存器（辅助位）**：一个单独的位，初始为0。
>
> - 在算法执行过程中，**A 寄存器和 Q 寄存器在物理上是连接在一起的**。
> - 它们可以共同进行**算术右移**操作。
> - 这个“A寄存器 + Q寄存器”的组合体，就被称为**乘积寄存器**。
>
> > **为什么要把它们看成一个整体？**
> >
> > 因为最终的乘积结果的位数，是原始操作数（被乘数和乘数）位数的两倍。
> >
> > - 例如，两个4位的数相乘，会得到一个8位的结果。
> > - `A` 寄存器是4位，`Q` 寄存器也是4位。将它们连接起来，正好是8位（`A` 是结果的高4位，`Q` 是结果的低4位）。
>
> **操作规则（根据 Q₀ 和 Q₋₁ 的值判断）：**
>
> | Q₀（当前位） | Q₋₁（前一位） | 操作说明                                    |
> | :----------- | :------------ | :------------------------------------------ |
> | 0            | 0             | **连续0**：仅进行**算术右移**               |
> | 0            | 1             | **01序列**：**A = A + M**，然后**算术右移** |
> | 1            | 0             | **10序列**：**A = A - M**，然后**算术右移** |
> | 1            | 1             | **连续1**：仅进行**算术右移**               |
>
> 1. **循环次数 n = 乘数 Q 的位数。**
> 2. 而这个**共同的位数 n 的选择标准是：它必须大于等于能表示被乘数 M 和乘数 Q 各自所需的最小位宽中的较大者**。


## 除法

不同情形的处理

- 若被除数为0，除数不为0：商为0
- 若被除数不为0，除数为0：发生“除数为0”异常
- 若被除数、除数均为0：发生“除法错”异常
- 若被除数、除数均不为0：进行进一步除法运算

先问一个问题：`（-7）/3`的答案是`-2`余`-1`还是`-3`余`2`？

前者！！！！计算机的视角里，做除法是让被除数的绝对值不断变小的过程，余数必须和被除数符号一样！！！

读者可以利用C语言自己试试

> 注意，编程语言亦有区别！
>
> 1. **向零取整 (Truncate toward zero)**：让商向零的方向舍入。这是 C、C++、Java 等语言采用的方式。按照这种方式，`(-7) / 3` 的商是 `-2`，余数是 `-1`。这符合你的第一种想法。
> 2. **向下取整 (Floor toward -∞)**：让商向负无穷的方向舍入。这是 **Python、Ruby、Haskell** 等语言采用的方式。按照这种方式，`(-7) / 3` 的商是 `-3`，余数是 `2`。



### 无符号数

<img src="https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925152901023.png" alt="image-20250925152901023" style="zoom:50%;" />

![image-20250925152936537](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925152936537.png)

### 补码

#### 如何判断“够减”：余数是否足够“大”

如果余数和除数的符号相同：减法
如果余数和除数的符号不同：加法

![image-20250925154304494](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images/image-20250925154304494.png)

#### 步骤过程

通过在前面加n位符号扩展被除数，并存储在余数寄存器和商寄存器中
将余数和商左移，判断是否“够减”
 • 如果“够”，则做减法（同号）或者加法（异号），并上商为1
 • 如果“不够，则上商为0
重复以上步骤
如果除数和被除数不同号，则将商替换为其相反数
余数存在余数寄存器中

### 恢复余数

### 不恢复余数
