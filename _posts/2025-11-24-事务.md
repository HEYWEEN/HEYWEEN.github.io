---
title: "事务"
date: 2025-11-24  # 文章发布时间
categories: [数据管理基础] # 你的分类
tags: [笔记]     # 你的标签
math: true
---

# 并发

## 并发控制概述

事务是并发控制的基本单位

事务的ACID特性可能遭到破坏的原因之一：多个事务进行并发操作互相干扰

为了保证事务的隔离性和一致性，需要对并发操作进行正确调度

### 并发操作带来数据不一致性：丢失修改、脏读、不可重复读、幻读

1. 丢失修改：两个事务T1和T2读入同一数据并修改， T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。
2. 脏读：
   - 事务T1修改某一数据，并将其写回磁盘事务
   - T2读取同一数据后， T1由于某种原因被撤销
   - 这时T1已修改过的数据恢复原值， T2读到的数据就与数据库中的数据不一致
   - T2读到的数据就为“脏”数据，即不正确的数据 
3. 不可重复读：
   - 不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果
   - 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值
4. 幻读：
   - 也称作幻影（phantom row）现象，是指事务T1读取数据后，事务T2执行插入或删除操作，使T1无法再现前一次读取结果。
   - 事务T1按一定条件从数据库中读取某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录“神秘地”消失了。 
   - 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。



数据不一致性：由于并发操作破坏了事务的隔离性

并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性

对数据库的应用有时允许某些不一致性，例如有些统计工作涉及数据量很大，读到一些“脏”数据对统计精度没什么影响，可以降低对一致性的要求以减少系统开销 



## 事务的隔离级别

控制越严格，隔离性越强，数据的一致性就越有保障，但系统的效率也会随之下降

四类隔离级别（由低到高）：

1. 读未提交：允许一个事务可以读取另一个未提交事务正在修改的数据。它可能出现脏读、不可重复读和幻读的情形。
2. 读已提交：只允许一个事务读其他事务已提交的数据。显然，“读已提交”可以有效避免读脏读，但是它不能保证可重复读和不幻读。
3. 可重复读：一个事务开始读取数据后，其他事务就不能再对该数据执行UPDATE操作了。“可重复读”杜绝了脏读和不可重复读，不能保证不幻读
4. 可串行化：最高的事务隔离级别，事务执行顺序是可串行化的，可以避免丢失修改、脏读、不可重复读和幻读



## 封锁

封锁：对数据项的访问加锁，防止其他事务访问

![截屏2025-11-24 19.35.49](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-11-24%2019.35.49.png)



## 封锁协议

![截屏2025-11-24 19.34.59](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-11-24%2019.34.59.png)



## 活锁和死锁

- 活锁：系统先满足后来事务的请求，先来的事务一直在等待锁，无法继续执行
  - 采用先来先服务的方式
- 死锁：两个或多个事务互相等待对方释放锁，导致无法继续执行
  - 解除死锁：撤销处理代价最小的事务并释放锁，使其他事务继续执行

#### 检测死锁

> OS 中预防死锁的方式不适合数据库的特点

- 一次封锁法：事务将所需的数据一次性上锁
  - 牺牲并发度
- 顺序封锁法：定义上锁顺序，所有事务的上锁顺序一致
  - 实现复杂
- 超时法：事务等待锁的时间超过一定阈值则放弃
  - 实现简单
  - 可能误判
- 等待图法：间歇性生成事务等待图，如果存在回路则死锁
  - 节点：事务
  - 边：事务之间的等待关系