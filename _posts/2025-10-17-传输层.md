---
title: "传输层"
date: 2025-10-17  # 文章发布时间
categories: [互联网计算] # 你的分类
tags: [笔记]     # 你的标签
math: true
---

传输层依赖于网络层，是对网络层的加强。

网络层实现了主机到主机之间的通信，传输层实现了进程到进程之间的通信。

## 传输层提供的服务

![截屏2025-10-17 11.09.55](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-17%2011.09.55.png)

IP+端口号=进程

客户端主动发起通信，服务器被动通信

端口号分类只是一种“建议标准”，而不是“强制标准”

![截屏2025-10-20 09.33.57](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2009.33.57.png)

![截屏2025-10-20 09.47.11](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2009.47.11.png)

![截屏2025-10-20 09.47.45](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2009.47.45.png)

## UDP

### UDP vs TCP

![截屏2025-10-20 09.49.47](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2009.49.47.png)

![截屏2025-10-20 09.50.54](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2009.50.54.png)

### UDP数据报格式

![截屏2025-10-20 09.57.32](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2009.57.32.png)

但是因为UDP最终是要封装到IP数据报里的，受限于IP数据报，其实最大长度只有65515B

### UDP检验

![截屏2025-10-20 10.07.08](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.07.08.png)

![截屏2025-10-20 10.10.10](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.10.10.png)

![截屏2025-10-20 10.10.54](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.10.54.png)



## TCP

三大阶段：

- 建立连接（三次握手）
- 数据传输
- 释放连接（四次挥手）

![截屏2025-10-20 10.15.04](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.15.04.png)

释放连接的过程既可以是客户端先，也可以是服务器先

![截屏2025-10-20 10.18.13](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.18.13.png)

### TCP报文段

![截屏2025-10-20 10.21.54](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.21.54.png)

![截屏2025-10-20 10.23.44](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.23.44.png)

![截屏2025-10-20 10.28.29](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.28.29.png)

数据偏移部分实际上定义了TCP首部的长度---所以要计算TCP数据部分长度，必须要结合IP数据报的信息

![截屏2025-10-20 10.31.33](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.31.33.png)

![截屏2025-10-20 10.34.36](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.34.36.png)

![截屏2025-10-20 10.36.54](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.36.54.png)

![截屏2025-10-20 10.39.14](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.39.14.png)

![截屏2025-10-20 10.41.28](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.41.28.png)



### 三次握手

![截屏2025-10-20 10.47.20](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.47.20.png)

SYN=1:请求/同意请求连接

![截屏2025-10-20 10.51.43](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.51.43.png)

![截屏2025-10-20 10.53.59](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.53.59.png)

![截屏2025-10-20 10.56.23](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.56.23.png)

### 四次挥手

![截屏2025-10-20 10.57.44](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.57.44.png)

![截屏2025-10-20 10.59.49](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2010.59.49.png)

时间等待：因为接收方不一定成功收到挥手4，可能会重新发送挥手3，接着就会重新发送挥手4并且进入TIME-WAIT阶段

![截屏2025-10-20 11.02.05](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2011.02.05.png)

总结：

![截屏2025-10-20 11.03.20](https://cdn.jsdelivr.net/gh/HEYWEEN/images@main/images%E6%88%AA%E5%B1%8F2025-10-20%2011.03.20.png)





## 补充：rdt

`rdt` 是 **可靠数据传输** 的核心教学模型，也是理解 TCP 工作原理的基石，可以通过rdt深入传输层可靠通信的原理。

`rdt` 的全称是 **Reliable Data Transfer**。它通过一系列逐渐复杂的模型（`rdt 1.0`， `rdt 2.0`， `rdt 2.1`， `rdt 2.2`， `rdt 3.0`）来解决网络传输中可能遇到的各种问题。

---

### 核心问题：底层信道是不可靠的

网络信道可能会发生：
1.  **比特差错**：0变成1，1变成0。
2.  **数据丢失**：数据包或确认包在网络中“消失”了。
3.  **乱序**：（在更复杂的模型中）数据包不按顺序到达。

`rdt` 的目标就是在这样的不可靠信道上，**实现一个可靠的数据传输服务**。

---

### rdt 模型演进详解

#### 1. rdt 1.0：完全可靠的信道
*   **假设**：底层信道是**完全可靠**的！不会发生比特错误，也不会丢失数据包。
*   **机制**：
    *   **发送方**：只管发送数据。
    *   **接收方**：只管接收数据。
*   **评价**：这只是一个理想模型，为后续演进做铺垫。

#### 2. rdt 2.0：具有比特差错的信道
*   **引入问题**：信道可能产生**比特差错**，但数据包不会丢失。
*   **引入机制**：
    *   **差错检测**：发送方在包中添加校验和，接收方通过校验和判断数据是否出错。
    *   **接收方反馈**：接收方必须向发送方发送一个 **ACK** 或 **NAK**。
        *   `ACK`：确认包正确接收。
        *   `NAK`：否认，表示包有错误。
    *   **重传机制**：如果发送方收到 `NAK`，它会**重传**上一个数据包。
*   **工作流程**：
    1.  发送方发送一个包，然后等待接收方的 `ACK` 或 `NAK`。
    2.  接收方检查包：
        *   如果**无错**，回送 `ACK`。
        *   如果**有错**，回送 `NAK`。
    3.  发送方收到反馈：
        *   如果是 `ACK`，发送下一个包。
        *   如果是 `NAK`，**重传**当前包。
*   **缺陷**：如果 `ACK` 或 `NAK` 本身在传输中**出错或损坏**了怎么办？发送方无法知道接收方到底收到了没有。

#### 3. rdt 2.1 和 2.2：解决ACK/NAK损坏问题
*   **核心思想**：**取消NAK，只用ACK**。并通过在数据包和ACK包中引入**序号**来解决反馈信息的二义性。
*   **引入机制**：
    *   **序列号**：即使是简单的 `0` 和 `1` 交替序号也足够了。
    *   **发送方**：
        *   发送序号为 `0` 的数据包。
        *   如果收到对序号 `0` 的ACK，则发送序号为 `1` 的数据包。
        *   如果收到一个损坏的ACK，或者收到一个“错误”的ACK（比如期待对 `0` 的确认，却收到了对 `1` 的确认），它就**重传**当前数据包。
    *   **接收方**：
        *   检查序号。如果收到一个**重复的序号**（比如期望收到 `1`，却再次收到了 `0`），说明发送方没有收到上一次的ACK。此时，接收方会**再次发送ACK**，告知发送方：“我已经收到了这个包，请发下一个！”
*   **rdt 2.1 vs 2.2**：`rdt 2.2` 是对 `2.1` 的轻微优化，它完全取消了NAK。接收方通过回送一个**带有序号的ACK**来确认。例如，回送 `ACK 0` 表示“我期望收到序号为0的包”（即确认了序号为1的包之前的那个包）。
*   **评价**：至此，我们解决了比特差错和反馈信息损坏的问题。但数据包**丢失**的问题仍未解决。

#### 4. rdt 3.0：具有比特差错和丢包的信道
*   **引入问题**：数据包或ACK包可能会在信道中**丢失**。
*   **后果**：发送方会永远等待一个永远不会到来的ACK。
*   **引入机制**：**倒计数定时器**
    *   **发送方**在每次发送一个数据包后，都会启动一个定时器。
    *   如果在定时器**超时**前收到了对应的ACK，则定时器取消，发送下一个包。
    *   如果定时器**超时**了，无论是因为数据包丢了还是ACK丢了，发送方都会**重传**这个数据包，并重新启动定时器。
*   **工作流程**：这就是你熟悉的 **“停止-等待协议”**：
    1.  发送一个包，启动定时器。
    2.  等待。
    3.  可能发生三种情况：
        *   **ACK在超时前到达**：万事大吉，发下一个包。
        *   **数据包丢失**：定时器超时，重传。
        *   **ACK丢失**：定时器超时，重传。（接收方会收到重复包，但通过序号可以识别并丢弃它，同时再次发送ACK）。
*   **评价**：`rdt 3.0` 是一个功能完整的可靠数据传输协议！但它有一个致命缺点：**性能极低**。因为它是“停等”的，发送方在收到上一个包的ACK之前，不能发送下一个包，信道利用率非常低。

---

### 从 rdt 到 TCP

`rdt` 模型是TCP的设计原理，但TCP为了高性能，做了关键改进：

*   **流水线机制**：允许发送方在未收到确认前，连续发送多个分组。这正是你PPT中提到的 **“滑动窗口协议”** 和 **“连续ARQ”**。
*   **累计确认**：TCP接收方可以只确认最后一个按序到达的字节，表示之前的所有字节都已收到。
*   **更复杂的拥塞控制**：不仅仅是处理丢包（视为错误），还将丢包作为网络拥塞的信号，并主动降低发送速率。

### 总结

我们需要理解：

1.  **可靠传输要解决的根本问题**：差错、丢失、乱序。
2.  **实现可靠性的核心机制**：
    *   **校验和** -> 检测差错
    *   **确认ACK** -> 接收方反馈
    *   **序号** -> 处理重复、乱序和ACK二义性
    *   **定时器与重传** -> 处理丢失
3.  **从理想模型到现实模型的演进思路**。

理解了 `rdt`，再回头看TCP的三次握手、滑动窗口、超时重传等机制，就会觉得豁然开朗，因为它们都是为了在 `rdt` 的基础上实现**高性能**的可靠传输。