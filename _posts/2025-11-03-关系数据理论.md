---
title: "关系数据理论"
date: 2025-11-03  # 文章发布时间
categories: [数据管理基础] # 你的分类
tags: [笔记]     # 你的标签
math: true
---

> 前面已经讨论了数据库系统的一般概念，介绍了关系数据库的基本概念、关系模型的三个部分以及关系数据库的标准语言 SQL 。但是还有一个很基本的问题尚未涉及：针对一个具体问题，应该如何构造一个适合于它的数据库模式，即应该构造几个关系模式，每个关系由哪些属性组成等。这是数据库设计的问题，确切地讲是关系数据库逻辑设计问题。

# 规范化、关系模式及范式

## 关系模式

$$
R(U, D, DOM, F)
$$

- 关系名R是符号化的元组语义
- U为一组属性。定义了关系的结构，即表有哪些列。例如，一个学生关系可能有 `U = {学号, 姓名, 系名}`。
- D为属性组U中的属性所来自的域
- DOM为属性到域的映射
- F为属性组U上的一组数据依赖。定义了属性之间的约束关系，主要是函数依赖。例如 `F = { 学号 → 姓名, 学号 → 系名 }`，表示一个学号唯一确定一个姓名和一个系名。



而D、DOM和模式设计关系不大，所以在本章把关系模式看作一个三元组：
$$
R<U,F>
$$
当且仅当 U 上的一个关系 r 满足 F 时， r 称为关系模式 `R<U,F>` 的一个关系。

作为一个二维表，关系要符合一个最基本的条件：每一个分量必须是不可分的数据项。满足了这个条件的关系模式就属于第一范式 (1NF) 



## 1NF

1NF查起来很方便，因为不需要遇到`join`等

但是也有很多问题：

- 数据冗余度太大，浪费存储空间（Data redundancy）
  - 如：院长的姓名重复出现，重复次数与该学院所有学生的所有课程成绩出现次数相同。
- 更新异常（Update anomaly）数据冗余 ，更新数据时，维护数据完整性代价大
  - 如果某学院更换院长，系统必须修改与该学院学生有关的每一个元组。
- 插入异常（Insertion anomaly），该插入的数据插不进去
  - 如果新成立一个学院，尚无学生，我们就无法把这个学院及其院长的信息存入数据库。
- 删除异常（Deletion anomaly），不该删除的数据也删去了
  - 如果某个学院的学生全部毕业了， 我们在删除该学院学生信息的同时，把这个学院及其院长的信息也丢掉了。



结论：Student关系模式不是一个好的模式。一个“好”的模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。

原因：由存在于模式中的某些数据依赖引起的

解决方法：用规范化理论改造关系模式来消除其中不合适的数据依赖



## 函数依赖

- **普遍存在**于现实生活中。
- **示例**：在关系模式 `STUDENT(Sno, School, Mname, Cno, Grade)` 中，存在以下函数依赖：
  - `Sno → School` （学号决定所在学院）
  - `School → Mname` （学院决定院长姓名）
  - `(Sno, Cno) → Grade` （学号和课程号共同决定成绩）
- **问题**：关系中存在**不完全的函数依赖**和**传递函数依赖**，是导致模式“不好”的根源。



## 范式

范式是衡量关系模式规范化程度的标准。

### 第一范式

- **最基本要求**：关系的每一个分量必须是**不可再分**的原子数据项。
- **问题**：即使满足1NF，关系模式仍可能存在严重问题（如数据冗余、插入/删除/更新异常）。
- **原因**：存在不合适的函数依赖。

### 范式的种类与联系

- **范式的种类**（由低到高）：
  1. 第一范式 (1NF)
  2. 第二范式 (2NF)
  3. 第三范式 (3NF)
  4. BC范式 (BCNF)
  5. 第四范式 (4NF)
  6. 第五范式 (5NF)
- **范式间的联系**：
  - 高级别范式包含在低级别范式之中。
  - 一个低级别范式的关系模式，通过**模式分解**可以转换为若干个高级别范式关系模式的集合。
  - 这个过程称为**规范化**。





# 函数依赖与码

## 函数依赖的定义

给定关系模式 $ R(U, F) $，其中 $ X $ 和 $ Y $ 是属性集 $ U $ 的子集。若对于 $ R $ 的任意一个可能的关系 $ r $，都不存在两个元组在 $ X $ 上的属性值相等，而在 $ Y $ 上的属性值不等，则称 **X 函数确定 Y**，或称 **Y 函数依赖于 X**，记作：

$$
X \rightarrow Y
$$

- $ X $ 称为该函数依赖的**决定属性组**或**决定因素**。
- 若 $ X \rightarrow Y $ 且 $ Y \rightarrow X $，则记为 $X \leftrightarrow Y$。
- 若 $ Y $ 不函数依赖于 $ X $，则记为 $ X \nrightarrow Y $。

**示例**：  
关系模式 $STUDENT(Sno, School, Mname, Cno, Grade)$  
函数依赖集 $ F $ 为：
$\{ Sno \rightarrow School,\ School \rightarrow Mname,\ (Sno, Cno) \rightarrow Grade \}$

---

## 函数依赖的确定

- 函数依赖是**语义范畴**的概念，只能根据数据的实际含义来确定。
- 数据库设计者可以**强制规定**某些语义约束，如规定"姓名 → 年龄"在无重名条件下成立。
- 函数依赖是指**所有关系实例**都必须满足的约束，而非个别实例。

> ❗ 不能仅凭一个关系实例推断函数依赖，必须考虑所有可能实例。

---

## 函数依赖的分类

### 1. 平凡函数依赖 vs 非平凡函数依赖

- **非平凡函数依赖**：  
  $X \rightarrow Y$，且 $Y \nsubseteq X$  
  例如：$(Sno, Cno) \rightarrow Grade$

- **平凡函数依赖**：  
  $X \rightarrow Y$，且 $Y \subseteq X$  
  例如：$(Sno, Cno) \rightarrow Sno$，$(Sno, Cno) \rightarrow Cno$

> 注：平凡函数依赖必然成立，不反映新语义，通常我们只讨论**非平凡函数依赖**。

---

### 2. 完全函数依赖 vs 部分函数依赖

在 $ R(U, F) $ 中，若 $ X \rightarrow Y $，且对 $ X $ 的**任意真子集** $ X' $，都有 $ X' \nrightarrow Y $，则称 $ Y $ 对 $ X $ **完全函数依赖**，记作：

$ X \xrightarrow{F} Y $

若 $X \rightarrow Y$，但 $Y$ 不完全依赖于 $X$，则称 $Y$ 对 $X$ **部分函数依赖**，记作：

$X \xrightarrow{P} Y$

**示例**：  
在 $STUDENT(Sno, School, Mname, Cno, Grade)$ 中：

- $(Sno, Cno) \xrightarrow{F} Grade$
- $ (Sno, Cno) \xrightarrow{P} School $，因为 $ Sno \rightarrow School $，而 $ Sno $ 是 $ (Sno, Cno) $ 的真子集。
- “在分析依赖关系时，我们暂时**不考虑 Cno 这个属性列**，只关注 Sno 单独能否决定 Grade”，这就是“真子集”的含义！而不是删除某一个具体的行或者列！！！

---

### 3. 传递函数依赖

在 $ R(U, F) $ 中，若满足：

$X \rightarrow Y$，$Y \nsubseteq X$，$Y \nrightarrow X$，$Y \rightarrow Z$，$Z \nsubseteq Y$

则称 $Z$ 对 $X$ **传递函数依赖**，记作：

$X \xrightarrow{传递} Z$

> 注：若 $Y \rightarrow X$（即 $X \leftrightarrow Y$），则 $Z$ 直接依赖于 $X$，不构成传递依赖。

**示例**：  
在 $STUDENT(Sno, School, Mname, Cno, Grade)$ 中：

$Sno \rightarrow School$，$School \rightarrow Mname$ $\Rightarrow$ $Sno \xrightarrow{传递} Mname$

---

## 四、码的定义与分类

### 1. 候选码与超码

设 $ K $ 为 $ R(U, F) $ 中的属性或属性组合：

- 若 $K \xrightarrow{F} U$，则 $K$ 称为 $R$ 的**候选码**。
- 若 $K \rightarrow U$，则 $K$ 称为**超码**。

> - 候选码是最小的超码。
> - 候选码的任何真子集都不能成为超码。
> - 若关系模式有多个候选码，则选定一个作为**主码**。

**示例**：

- $Student(Sno, Sname, Ssex, Sbirthdate, Smajor)$，$Sno$ 是码。
- $SC(Sno, Cno, Grade, Semester, Teachingclass)$，$(Sno, Cno)$ 是码。
- 若学生无重名，则 $Sno$ 和 $Sname$ 都是候选码，可选 $Sno$ 为主码。

---

### 2. 主属性与非主属性

- **主属性**：包含在**任一候选码**中的属性。
- **非主属性**：不包含在任何候选码中的属性。
- **全码**：整个属性组都是码，称为全码（All-Key）。

**示例**：

- $Student$ 中，$Sno$ 是主属性，其余为非主属性。
- $SC$ 中，$Sno, Cno$ 是主属性，其余为非主属性。
- $R(P, W, A)$ 表示演奏者、作品、听众，语义上三者共同决定一个记录，故为全码。

---

### 3. 外码

**定义 6.5**  
关系模式 $R$ 中的属性或属性组 $X$ 不是 $R$ 的码，但 $X$ 是另一个关系模式的码，则称 $X$ 是 $R$ 的**外码**。

> 外码与主码共同实现了关系之间的关联。

**示例**：  
在 $SC(Sno, Cno, Grade, ...)$ 中，$Sno$ 不是码，但 $Sno$ 是 $Student$ 表的主码，因此 $Sno$ 是 $SC$ 的外码。

---

## 总结

| 概念         | 符号                       | 说明                    |
| ------------ | -------------------------- | ----------------------- |
| 函数依赖     | $X \rightarrow Y$          | $X$ 唯一决定 $Y$        |
| 完全函数依赖 | $X \xrightarrow{F} Y$      | $Y$ 依赖于 $X$ 的全部   |
| 部分函数依赖 | $X \xrightarrow{P} Y$      | $Y$ 依赖于 $X$ 的一部分 |
| 传递函数依赖 | $X \xrightarrow{传递} Z$   | 通过 $Y$ 间接依赖       |
| 候选码       | $K \xrightarrow{F} U$      | 最小唯一标识            |
| 超码         | $K \rightarrow U$          | 包含候选码的属性集      |
| 外码         | $X$ 非本关系码，是它关系码 | 实现关系间连接          |

