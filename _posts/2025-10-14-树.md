---
title: "树"
date: 2025-10-14  # 文章发布时间
categories: [数据结构与算法] # 你的分类
tags: [笔记]     # 你的标签
math: true
---

> 树和图是最常见的非线性数据结构



## 一、树的基本概念

### 1. 定义
- 树是节点的有限集合。
- 可以为空，否则包含一个根节点和若干子树。

### 2. 术语
- **度**：节点的子节点数。
- **叶子**：度为0的节点。
- **分支节点**：度不为0的节点。
- **层次**：根为0或1，逐层递增。
- **深度/高度**：树中节点的最大层次。

---

## 二、二叉树

### 1. 定义
- 有限节点集合，每个节点最多有两个子树（左、右）。

### 2. 与一般树的区别
- 每个节点最多有两个子树。
- 子树有顺序（左、右）。

### 3. 性质
1. 有 `n` 个节点的二叉树有 `n-1` 条边。
2. 第 `i` 层最多有 `2^i` 个节点。
3. 高度为 `h` 的二叉树节点数在 `h+1` 到 `2^(h+1)-1` 之间。
4. 叶子节点数 `n0 = n2 + 1`（度为2的节点数）。
5. 高度 `h` 满足：  
   \[
   \lceil \log_2(n+1) \rceil - 1 \leq h \leq n-1
   \]

### 4. 特殊二叉树
- **满二叉树**：高度 `h`，节点数为 `2^(h+1)-1`。
- **完全二叉树**：从满二叉树中删除最后 `k` 个节点。

---

## 三、二叉树的存储表示

### 1. 顺序存储（数组）
- 适用于完全二叉树。
- 节点 `i` 的左子：`2i+1`，右子：`2i+2`，父：`⌊(i-1)/2⌋`。

### 2. 链式存储
```cpp
class BinaryNode {
public:
    BinaryNode() { Left = Right = 0; }
    BinaryNode(Object e) { element = e; Left = Right = 0; }
    BinaryNode(Object e, BinaryNode* l, BinaryNode* r) {
        element = e; Left = l; Right = r;
    }
    Object element;
    BinaryNode* Left;
    BinaryNode* Right;
};
```

### 3. 游标表示法（模拟链表）
- 使用数组存储节点，`leftchild` 和 `rightchild` 存储子节点索引。

---

## 四、二叉树的操作与遍历

### 1. 基本操作
- `Create()`, `IsEmpty()`, `Root()`, `MakeTree()`, `BreakTree()`



```java
template<class T>
class BinaryTree {
public:
    // 构造函数和析构函数
    BinaryTree() { root = 0; };
    ~BinaryTree() { Destroy(root); };
    
    // 基本判断操作
    bool IsEmpty() const { 
        return (root) ? false : true; 
    }
    
    // 获取根节点值
    bool Root(T& x) const {
        if (root) {
            x = root->element;
            return true;
        }
        return false;
    }
    
    // 构建二叉树
    void MakeTree(const T& data, BinaryTree<T>& leftch, BinaryTree<T>& rightch);
    
    // 分解二叉树
    void BreakTree(T& data, BinaryTree<T>& leftch, BinaryTree<T>& rightch);
    
    // 遍历操作
    void PreOrder(void(*visit)(BinaryNode<T>* u)) { 
        PreOrder(visit, root); 
    }
    
    void InOrder(void(*visit)(BinaryNode<T>* u)) { 
        InOrder(visit, root); 
    }
    
    void PostOrder(void(*visit)(BinaryNode<T>* u)) { 
        PostOrder(visit, root); 
    }
    
    void LevelOrder(void(*visit)(BinaryNode<T>* u));

private:
    BinaryNode<T>* root;
    
    // 私有递归遍历方法
    void PreOrder(void(*visit)(BinaryNode<T>* u), BinaryNode<T>* t);
    void InOrder(void(*visit)(BinaryNode<T>* u), BinaryNode<T>* t);
    void PostOrder(void(*visit)(BinaryNode<T>* u), BinaryNode<T>* t);
    
    // 销毁二叉树
    void Destroy(BinaryNode<T>* t);
};
```



### 2. 遍历方式
- **先序**：VLR
- **中序**：LVR
- **后序**：LRV
- **层序**：按层次遍历

### 3. 递归遍历代码

> 只要用递归写出来的算法，都是深度优先的；而按层次遍历是广度优先

#### 先序遍历
```cpp
template<class T>
void PreOrder(BinaryNode<T>* t) {
    if (t) {
        visit(t);
        PreOrder(t->Left);
        PreOrder(t->Right);
    }
}
```

#### 中序遍历
```cpp
template<class T>
void InOrder(BinaryNode<T>* t) {
    if (t) {
        InOrder(t->Left);
        visit(t);
        InOrder(t->Right);
    }
}
```

#### 后序遍历
```cpp
template<class T>
void PostOrder(BinaryNode<T>* t) {
    if (t) {
        PostOrder(t->Left);
        PostOrder(t->Right);
        visit(t);
    }
}
```

#### 层序遍历（使用队列）
```cpp
template<class T>
void LevelOrder(BinaryNode<T>* t) {
    LinkedQueue<BinaryNode<T>*> Q;
    while (t) {
        visit(t);
        if (t->Left) Q.Add(t->Left);
        if (t->Right) Q.Add(t->Right);
        try { Q.Delete(t); }
        catch (OutOfBounds) { return; }
    }
}
```

---

## 五、非递归遍历算法

### 1. 中序遍历（使用栈）
```cpp
void Inorder(BinaryNode<T>* t) {
    Stack<BinaryNode<T>*> s(10);
    BinaryNode<T>* p = t;
    for (;;) {
        while (p != NULL) {
            s.push(p);
            p = p->Left;
        }
        if (!s.IsEmpty()) {
            p = s.pop();
            cout << p->element;
            p = p->Right;
        } else return;
    }
}
```

### 2. 后序遍历（使用栈和标记）
```cpp
struct StkNode {
    BinaryNode<T>* ptr;
    int tag;
};

void Postorder(BinaryNode<T>* t) {
    Stack<StkNode<T>> s(10);
    StkNode<T> Cnode;
    BinaryNode<T>* p = t;
    for (;;) {
        while (p != NULL) {
            Cnode.ptr = p;
            Cnode.tag = 0;
            s.push(Cnode);
            p = p->Left;
        }
        Cnode = s.pop();
        p = Cnode.ptr;
        while (Cnode.tag == 1) {
            cout << p->element;
            if (!s.IsEmpty()) {
                Cnode = s.pop();
                p = Cnode.ptr;
            } else return;
        }
        Cnode.tag = 1;
        s.push(Cnode);
        p = p->Right;
    }
}
```

---

## 六、二叉树的构建方法

### 1. 使用 `MakeTree`
```cpp
void MakeTree(const T& data, BinaryTree<T>& leftch, BinaryTree<T>& rightch) {
    root = new BinaryNode<T>(data, leftch.root, rightch.root);
    leftch.root = rightch.root = 0;
}
```

### 2. 使用先序和中序序列
```cpp
void CreateBT(String pres, String ins, BinaryNode<Type>*& t) {
    int inpos;
    String prestemp, instemp;
    if (pres.length() == 0) t = NULL;
    else {
        t = new BinaryNode;
        t->element = pres.ch[0];
        inpos = 0;
        while (ins.ch[inpos] != t->element) inpos++;
        prestemp = pres(1, inpos);
        instemp = ins(0, inpos - 1);
        CreateBT(prestemp, instemp, t->left);
        prestemp = pres(inpos + 1, pres.length() - 1);
        instemp = ins(inpos + 1, ins.length() - 1);
        CreateBT(prestemp, instemp, t->right);
    }
}
```

### 3. 使用广义表表示
- 例如：`A(B(D), C(E(.,G), F(H,I)))`

---

## 七、树与森林

### 1. 树的存储表示
- 广义表、双亲表示法、左子女-右兄弟表示法

### 2. 树转二叉树
- 左子女-右兄弟表示法

### 3. 森林转二叉树
- 每棵树转为二叉树，根用右链相连

### 4. 树的遍历
- **先根遍历** ↔ 二叉树的先序遍历
- **后根遍历** ↔ 二叉树的中序遍历

---

## 八、线索二叉树

### 1. 目的
- 利用空指针域指向遍历序列的前驱或后继

### 2. 节点结构
```cpp
class ThreadNode {
    int leftThread, rightThread;
    ThreadNode* leftchild, * rightchild;
    Type data;
};
```

### 3. 中序线索树的遍历
```cpp
ThreadNode<Type>* First() {
    while (current->leftThread == 0) current = current->leftchild;
    return current;
}

ThreadNode<Type>* Next() {
    ThreadNode<Type>* p = current->rightchild;
    if (current->rightThread == 0)
        while (p->leftThread == 0) p = p->leftchild;
    current = p;
}
```

---

## 九、哈夫曼树与编码

### 1. 哈夫曼树
- 带权路径长度最小的二叉树

### 2. 哈夫曼编码
- 用于数据压缩，前缀编码

---

## 十、广义表

### 1. 定义
- 元素可以是原子或子表的有序序列

### 2. 存储结构
- 使用联合体表示不同类型节点

### 3. 基本操作
- `head()`, `tail()`, `depth()`, `copy()`, `equal()`

### 4. 递归算法示例
#### 求深度
```cpp
int GenList::depth(GenListNode* ls) {
    if (ls->tlink == NULL) return 1;
    GenListNode* temp = ls->tlink;
    int m = 0;
    while (temp != NULL) {
        if (temp->utype == LST) {
            int n = depth(temp->value.hlink);
            if (m < n) m = n;
        }
        temp = temp->tlink;
    }
    return m + 1;
}
```

---

## 十一、习题与考题

- 包含多种二叉树、哈夫曼树、广义表的应用题和算法题。
- 例如：统计叶子数、交换左右子树、构造哈夫曼树、判断二叉树性质等。

---

如果有需要修改或者补充的地方，可以随时告诉我。