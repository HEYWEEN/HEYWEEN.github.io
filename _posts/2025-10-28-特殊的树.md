---
title: "特殊的树"
date: 2025-10-28  # 文章发布时间
categories: [数据结构与算法] # 你的分类
tags: [笔记]     # 你的标签
math: true
---

在离散数学中，N个节点、N-1条边就是树，并不必须要提到根。

至于为什么节点和边是这样的关系，因为不能成环！

树是二部图

> 二部图是一种特殊的图，它的所有节点可以被划分到两个独立的集合（比如集合A和集合B）中，并且满足：
>
> - 图中的**每一条边**都连接着一个属于集合A的节点和一个属于集合B的节点。
> - **同一集合内部（A内部或B内部）的任意两个节点之间没有边直接相连。**

## 二叉搜索树

### 1.定义

一个二叉搜索树要么是空树，要么是满足以下性质的二叉树：

1. 每个元素都有一个键值，所有键值都是**互异**的。
2. 根节点左子树中所有键值**小于**根节点的键值。
3. 根节点右子树中所有键值**大于**根节点的键值。
4. 左子树和右子树本身也是二叉搜索树。

> **核心**：利用二叉树结构，通过比较键值实现快速查找。

### 2. 索引二叉搜索树

- 在普通二叉搜索树的基础上，为每个节点增加一个 `leftSize` 字段。
- `leftSize` = 该节点**左子树的元素个数 + 1**（即包括该节点在内的左子树元素总数）。
- **用途**：可以快速查找第 k 小的元素。

------

### 3. 类结构

- `BinaryNode` 类：包含 `element`（可比较的元素）、`left`（左孩子）、`right`（右孩子）。
- `BinarySearchTree` 类：包含根节点 `root`，以及一系列方法：
  - `find(x)`, `findMin()`, `findMax()`
  - `insert(x)`, `remove(x)`
  - `printTree()`

------

### 4. 查找操作

- `find(x, t)`：递归实现。
  - 如果 `t == null`，返回 `null`。
  - 如果 `x < t.element`，在左子树中查找。
  - 如果 `x > t.element`，在右子树中查找。
  - 否则，找到并返回该节点。

------

### 5. 查找最小/最大值

- `findMin(t)`：递归地一直向左走，直到没有左孩子。
- `findMax(t)`：非递归地一直向右走，直到没有右孩子。

------

### 6. 插入操作

- `insert(x, t)`：
  - 如果 `t == null`，创建新节点。
  - 否则，递归地插入到左子树或右子树。
  - 如果重复，不做任何操作。

------

### 7. 删除操作

删除节点分为三种情况：

1. **叶子节点**：直接删除。
2. **只有一个非空子树**：用其唯一的孩子替换它。
3. **有两个非空子树**：
   - 用其右子树中的最小元素（或左子树中的最大元素）替换该节点。
   - 再递归地删除那个最小（或最大）元素。

------

### 8. 高度与性能

- **最坏情况**：插入有序序列，树退化为链表，高度为 O(n)，操作时间复杂度为 O(n)。
- **最好/平均情况**：树高度为 O(log n)，操作时间复杂度为 O(log n)。



```c++
#include <iostream>
#include <memory>
using namespace std;

// 二叉搜索树节点类
template <typename T>
class BinaryNode {
public:
    T element;          // 节点存储的数据
    BinaryNode* left;   // 左孩子指针
    BinaryNode* right;  // 右孩子指针
    
    // 构造函数
    BinaryNode(const T& theElement, BinaryNode* lt = nullptr, BinaryNode* rt = nullptr)
        : element(theElement), left(lt), right(rt) {}
    
    // 拷贝构造函数
    BinaryNode(const BinaryNode& rhs)
        : element(rhs.element), left(nullptr), right(nullptr) {
        if (rhs.left != nullptr)
            left = new BinaryNode(*rhs.left);
        if (rhs.right != nullptr)
            right = new BinaryNode(*rhs.right);
    }
    
    // 析构函数
    ~BinaryNode() {
        delete left;
        delete right;
    }
};
```



```c++
template <typename T>
class BinarySearchTree {
private:
    BinaryNode<T>* root;  // 根节点指针

public:
    // 构造函数和析构函数
    BinarySearchTree() : root(nullptr) {}
    BinarySearchTree(const BinarySearchTree& rhs) : root(nullptr) {
        root = clone(rhs.root);
    }
    ~BinarySearchTree() {
        makeEmpty();
    }
    
    // 基础操作
    void makeEmpty() {
        makeEmpty(root);
    }
    
    bool isEmpty() const {
        return root == nullptr;
    }
    
    // 查找操作
    bool contains(const T& x) const {
        return contains(x, root);
    }
    
    const T& findMin() const {
        return findMin(root)->element;
    }
    
    const T& findMax() const {
        return findMax(root)->element;
    }
    
    // 插入删除操作
    void insert(const T& x) {
        insert(x, root);
    }
    
    void remove(const T& x) {
        remove(x, root);
    }
    
    // 打印操作
    void printTree(ostream& out = cout) const {
        if (isEmpty())
            out << "Empty tree" << endl;
        else
            printTree(root, out);
    }
    
    // 中序遍历
    void inorderTraversal() const {
        inorderTraversal(root);
        cout << endl;
    }

private:
    // 私有辅助方法
    bool contains(const T& x, BinaryNode<T>* t) const;
    BinaryNode<T>* findMin(BinaryNode<T>* t) const;
    BinaryNode<T>* findMax(BinaryNode<T>* t) const;
    void insert(const T& x, BinaryNode<T>*& t);
    void remove(const T& x, BinaryNode<T>*& t);
    void makeEmpty(BinaryNode<T>*& t);
    BinaryNode<T>* clone(BinaryNode<T>* t) const;
    void printTree(BinaryNode<T>* t, ostream& out) const;
    void inorderTraversal(BinaryNode<T>* t) const;
};
```



```c++
// 查找操作 - 递归实现
template <typename T>
bool BinarySearchTree<T>::contains(const T& x, BinaryNode<T>* t) const {
    if (t == nullptr)
        return false;
    else if (x < t->element)
        return contains(x, t->left);
    else if (x > t->element)
        return contains(x, t->right);
    else
        return true;  // 匹配成功
}

// 查找最小值 - 递归实现
template <typename T>
BinaryNode<T>* BinarySearchTree<T>::findMin(BinaryNode<T>* t) const {
    if (t == nullptr)
        return nullptr;
    if (t->left == nullptr)
        return t;
    return findMin(t->left);
}

// 查找最大值 - 非递归实现
template <typename T>
BinaryNode<T>* BinarySearchTree<T>::findMax(BinaryNode<T>* t) const {
    if (t != nullptr)
        while (t->right != nullptr)
            t = t->right;
    return t;
}

// 插入操作
template <typename T>
void BinarySearchTree<T>::insert(const T& x, BinaryNode<T>*& t) {
    if (t == nullptr)
        t = new BinaryNode<T>(x);
    else if (x < t->element)
        insert(x, t->left);
    else if (x > t->element)
        insert(x, t->right);
    // else 重复元素，不做任何操作
}

// 删除操作 - 最复杂的方法
template <typename T>
void BinarySearchTree<T>::remove(const T& x, BinaryNode<T>*& t) {
    if (t == nullptr)
        return;  // 没找到要删除的元素
    
    if (x < t->element)
        remove(x, t->left);
    else if (x > t->element)
        remove(x, t->right);
    else if (t->left != nullptr && t->right != nullptr) {
        // 情况3：有两个孩子
        t->element = findMin(t->right)->element;
        remove(t->element, t->right);
    } else {
        // 情况1或2：叶子节点或只有一个孩子
        BinaryNode<T>* oldNode = t;
        t = (t->left != nullptr) ? t->left : t->right;
        oldNode->left = oldNode->right = nullptr;  // 避免递归删除
        delete oldNode;
    }
}

// 清空树
template <typename T>
void BinarySearchTree<T>::makeEmpty(BinaryNode<T>*& t) {
    if (t != nullptr) {
        makeEmpty(t->left);
        makeEmpty(t->right);
        delete t;
    }
    t = nullptr;
}

// 克隆树 - 用于拷贝构造函数
template <typename T>
BinaryNode<T>* BinarySearchTree<T>::clone(BinaryNode<T>* t) const {
    if (t == nullptr)
        return nullptr;
    else
        return new BinaryNode<T>(t->element, clone(t->left), clone(t->right));
}

// 打印树 - 中序遍历
template <typename T>
void BinarySearchTree<T>::printTree(BinaryNode<T>* t, ostream& out) const {
    if (t != nullptr) {
        printTree(t->left, out);
        out << t->element << " ";
        printTree(t->right, out);
    }
}

// 中序遍历
template <typename T>
void BinarySearchTree<T>::inorderTraversal(BinaryNode<T>* t) const {
    if (t != nullptr) {
        inorderTraversal(t->left);
        cout << t->element << " ";
        inorderTraversal(t->right);
    }
}
```



## **AVL 树**

### 1. 定义与目的

- AVL 树是一种**自平衡二叉搜索树**。
- 每个节点的平衡因子 = 右子树高度 - 左子树高度，其值只能为 -1, 0, 1。
- **目的**：避免二叉搜索树退化为链表，保证查询、插入、删除的最坏时间复杂度为 O(log n)。

------

### 2. 平衡因子

- `bf(node) = height(right) - height(left)`
- 若 `|bf| > 1`，则该节点不平衡，需要调整。

------

### 3. 插入操作与旋转

插入后可能导致不平衡，需从插入点向上回溯，找到第一个不平衡节点进行调整。

#### 情况1：外侧插入 → 单旋转

- **左单旋**（插入在右子树的右子树）
- **右单旋**（插入在左子树的左子树）

#### 情况2：内侧插入 → 双旋转

- **左右双旋**（插入在左子树的右子树）：先左旋再右旋。
- **右左双旋**（插入在右子树的左子树）：先右旋再左旋。

> **旋转后，以该节点为根的子树高度恢复为插入前的高度**，不会影响更上层的节点。

------

### 4. 删除操作

- 删除方法与二叉搜索树相同。
- 删除后可能引起多个节点不平衡，需从删除点向上回溯并调整平衡。

------

### 5. 高度分析

- AVL 树的高度为 O(log n)。
- 最小节点数递推公式：`N_h = N_{h-1} + N_{h-2} + 1`，与斐波那契数列相关。



```c++
#include <iostream>
#include <algorithm>
using namespace std;

// AVL树节点类
template <typename T>
class AVLNode {
public:
    T element;           // 节点存储的数据
    AVLNode* left;       // 左孩子指针
    AVLNode* right;      // 右孩子指针
    int height;          // 节点高度
    
    // 构造函数
    AVLNode(const T& theElement, AVLNode* lt = nullptr, AVLNode* rt = nullptr, int h = 0)
        : element(theElement), left(lt), right(rt), height(h) {}
    
    // 拷贝构造函数
    AVLNode(const AVLNode& rhs)
        : element(rhs.element), left(nullptr), right(nullptr), height(rhs.height) {
        if (rhs.left != nullptr)
            left = new AVLNode(*rhs.left);
        if (rhs.right != nullptr)
            right = new AVLNode(*rhs.right);
    }
    
    // 析构函数
    ~AVLNode() {
        delete left;
        delete right;
    }
};
```



```c++
template <typename T>
class AVLTree {
private:
    AVLNode<T>* root;  // 根节点指针

public:
    // 构造函数和析构函数
    AVLTree() : root(nullptr) {}
    AVLTree(const AVLTree& rhs) : root(nullptr) {
        root = clone(rhs.root);
    }
    ~AVLTree() {
        makeEmpty();
    }
    
    // 基础操作
    void makeEmpty() {
        makeEmpty(root);
    }
    
    bool isEmpty() const {
        return root == nullptr;
    }
    
    // 查找操作
    bool contains(const T& x) const {
        return contains(x, root);
    }
    
    const T& findMin() const {
        return findMin(root)->element;
    }
    
    const T& findMax() const {
        return findMax(root)->element;
    }
    
    // 插入删除操作
    void insert(const T& x) {
        insert(x, root);
    }
    
    void remove(const T& x) {
        remove(x, root);
    }
    
    // 打印和遍历
    void printTree(ostream& out = cout) const {
        if (isEmpty())
            out << "Empty tree" << endl;
        else
            printTree(root, out);
    }
    
    void inorderTraversal() const {
        inorderTraversal(root);
        cout << endl;
    }
    
    // 获取树高度
    int getHeight() const {
        return height(root);
    }
    
    // 验证AVL性质
    bool isAVL() const {
        return isAVL(root);
    }

private:
    // 高度相关方法
    int height(AVLNode<T>* t) const {
        return t == nullptr ? -1 : t->height;
    }
    
    void updateHeight(AVLNode<T>* t) {
        if (t != nullptr)
            t->height = max(height(t->left), height(t->right)) + 1;
    }
    
    // 平衡因子
    int balanceFactor(AVLNode<T>* t) const {
        if (t == nullptr) return 0;
        return height(t->right) - height(t->left);
    }
    
    // 旋转操作
    AVLNode<T>* rotateWithLeftChild(AVLNode<T>* k2);     // 左单旋
    AVLNode<T>* rotateWithRightChild(AVLNode<T>* k1);    // 右单旋
    AVLNode<T>* doubleWithLeftChild(AVLNode<T>* k3);     // 左右双旋
    AVLNode<T>* doubleWithRightChild(AVLNode<T>* k1);    // 右左双旋
    
    // 平衡调整
    AVLNode<T>* balance(AVLNode<T>* t);
    
    // 核心操作
    bool contains(const T& x, AVLNode<T>* t) const;
    AVLNode<T>* findMin(AVLNode<T>* t) const;
    AVLNode<T>* findMax(AVLNode<T>* t) const;
    void insert(const T& x, AVLNode<T>*& t);
    void remove(const T& x, AVLNode<T>*& t);
    void makeEmpty(AVLNode<T>*& t);
    AVLNode<T>* clone(AVLNode<T>* t) const;
    void printTree(AVLNode<T>* t, ostream& out) const;
    void inorderTraversal(AVLNode<T>* t) const;
    bool isAVL(AVLNode<T>* t) const;
};
```



```c++
// 左单旋 (右子树右外侧插入)
template <typename T>
AVLNode<T>* AVLTree<T>::rotateWithLeftChild(AVLNode<T>* k2) {
    AVLNode<T>* k1 = k2->left;
    k2->left = k1->right;
    k1->right = k2;
    
    // 更新高度
    updateHeight(k2);
    updateHeight(k1);
    
    return k1;
}

// 右单旋 (左子树左外侧插入)
template <typename T>
AVLNode<T>* AVLTree<T>::rotateWithRightChild(AVLNode<T>* k1) {
    AVLNode<T>* k2 = k1->right;
    k1->right = k2->left;
    k2->left = k1;
    
    // 更新高度
    updateHeight(k1);
    updateHeight(k2);
    
    return k2;
}

// 左右双旋 (左子树右内侧插入)
template <typename T>
AVLNode<T>* AVLTree<T>::doubleWithLeftChild(AVLNode<T>* k3) {
    k3->left = rotateWithRightChild(k3->left);
    return rotateWithLeftChild(k3);
}

// 右左双旋 (右子树左内侧插入)
template <typename T>
AVLNode<T>* AVLTree<T>::doubleWithRightChild(AVLNode<T>* k1) {
    k1->right = rotateWithLeftChild(k1->right);
    return rotateWithRightChild(k1);
}
```



```c++
// 平衡调整
template <typename T>
AVLNode<T>* AVLTree<T>::balance(AVLNode<T>* t) {
    if (t == nullptr)
        return t;
    
    updateHeight(t);
    int bf = balanceFactor(t);
    
    // 左子树更高
    if (bf < -1) {
        if (balanceFactor(t->left) <= 0) {
            // 左左情况 - 右单旋
            return rotateWithLeftChild(t);
        } else {
            // 左右情况 - 左右双旋
            return doubleWithLeftChild(t);
        }
    }
    // 右子树更高
    else if (bf > 1) {
        if (balanceFactor(t->right) >= 0) {
            // 右右情况 - 左单旋
            return rotateWithRightChild(t);
        } else {
            // 右左情况 - 右左双旋
            return doubleWithRightChild(t);
        }
    }
    
    return t;  // 已经平衡
}
```



```c++
// 查找操作
template <typename T>
bool AVLTree<T>::contains(const T& x, AVLNode<T>* t) const {
    if (t == nullptr)
        return false;
    else if (x < t->element)
        return contains(x, t->left);
    else if (x > t->element)
        return contains(x, t->right);
    else
        return true;
}

// 查找最小值
template <typename T>
AVLNode<T>* AVLTree<T>::findMin(AVLNode<T>* t) const {
    if (t == nullptr)
        return nullptr;
    if (t->left == nullptr)
        return t;
    return findMin(t->left);
}

// 查找最大值
template <typename T>
AVLNode<T>* AVLTree<T>::findMax(AVLNode<T>* t) const {
    if (t != nullptr)
        while (t->right != nullptr)
            t = t->right;
    return t;
}

// 插入操作 - 核心方法
template <typename T>
void AVLTree<T>::insert(const T& x, AVLNode<T>*& t) {
    if (t == nullptr) {
        t = new AVLNode<T>(x);
        return;
    }
    
    if (x < t->element) {
        insert(x, t->left);
    } else if (x > t->element) {
        insert(x, t->right);
    } else {
        return;  // 重复元素，不插入
    }
    
    // 插入后平衡调整
    t = balance(t);
}

// 删除操作 - 核心方法
template <typename T>
void AVLTree<T>::remove(const T& x, AVLNode<T>*& t) {
    if (t == nullptr)
        return;  // 没找到要删除的元素
    
    if (x < t->element) {
        remove(x, t->left);
    } else if (x > t->element) {
        remove(x, t->right);
    } else if (t->left != nullptr && t->right != nullptr) {
        // 有两个孩子：用右子树最小值替换
        t->element = findMin(t->right)->element;
        remove(t->element, t->right);
    } else {
        // 叶子节点或只有一个孩子
        AVLNode<T>* oldNode = t;
        t = (t->left != nullptr) ? t->left : t->right;
        oldNode->left = oldNode->right = nullptr;
        delete oldNode;
        return;  // 删除后可能t为nullptr，直接返回
    }
    
    // 删除后平衡调整
    t = balance(t);
}

// 其他辅助方法
template <typename T>
void AVLTree<T>::makeEmpty(AVLNode<T>*& t) {
    if (t != nullptr) {
        makeEmpty(t->left);
        makeEmpty(t->right);
        delete t;
    }
    t = nullptr;
}

template <typename T>
AVLNode<T>* AVLTree<T>::clone(AVLNode<T>* t) const {
    if (t == nullptr)
        return nullptr;
    else
        return new AVLNode<T>(t->element, clone(t->left), clone(t->right), t->height);
}

template <typename T>
void AVLTree<T>::printTree(AVLNode<T>* t, ostream& out) const {
    if (t != nullptr) {
        out << "(";
        printTree(t->left, out);
        out << t->element << "(h:" << t->height << ",bf:" << balanceFactor(t) << ")";
        printTree(t->right, out);
        out << ")";
    }
}

template <typename T>
void AVLTree<T>::inorderTraversal(AVLNode<T>* t) const {
    if (t != nullptr) {
        inorderTraversal(t->left);
        cout << t->element << "(bf:" << balanceFactor(t) << ") ";
        inorderTraversal(t->right);
    }
}

// 验证AVL性质
template <typename T>
bool AVLTree<T>::isAVL(AVLNode<T>* t) const {
    if (t == nullptr)
        return true;
    
    int bf = balanceFactor(t);
    if (bf < -1 || bf > 1)
        return false;
    
    return isAVL(t->left) && isAVL(t->right);
}
```



## **B-树**

### 1. m 路搜索树

- 每个内部节点最多有 m 个子节点，包含 1 到 m-1 个元素。
- 元素按键值升序排列，子树键值范围划分明确。

------

### 2. B-树的定义

B-树是满足以下条件的 m 路搜索树：

1. 根节点至少有两个孩子。
2. 除根节点外，每个内部节点至少有 `⌈m/2⌉` 个子节点。
3. 所有外部节点在同一层。

> **外部节点**：即空指针，代表查找失败的位置。

------

### 3. 性质

- 外部节点数 = 关键字数 + 1。

- 高度 h 满足：
  $$
  \log_m (n+1) \le h \le 1 + \log_{\lceil m/2 \rceil} \frac{n+1}{2}
  $$
  

------

### 4. 查找

- 与 m 路搜索树查找方法相同。
- 每次访问一个节点，最多访问 h 次，适合磁盘 I/O 优化。

------

### 5. 插入

- 总是插入在某个内部节点的关键字列表中。
- **情况1**：节点未满，直接插入。
- **情况2**：节点已满，进行**分裂**：
  - 将节点分为两部分，中间关键字提升到父节点。
  - 若父节点也满，继续分裂，可能使树高增加。

------

### 6. 删除

#### a) 删除叶子节点中的关键字

- **情况1**：删除后节点仍满足最小关键字数要求，直接删除。
- **情况2**：删除后关键字数不足：
  - **借关键字**：从左或右兄弟节点借一个关键字，并调整父节点。
  - **合并**：若兄弟节点也不足，则与兄弟节点及父节点中对应关键字合并。

#### b) 删除内部节点中的关键字

- 用其前驱（左子树最大）或后继（右子树最小）替换。
- 再递归地删除那个前驱或后继。

------

### 7. 节点结构

- 表示为：`[s, c0, (e1, c1), (e2, c2), ..., (es, cs)]`
- `s`：关键字个数
- `ei`：关键字
- `ci`：子节点指针



```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// B-树节点类
template <typename T, int M>
class BTreeNode {
public:
    vector<T> keys;           // 关键字数组
    vector<BTreeNode*> children; // 子节点指针数组
    bool leaf;                // 是否为叶子节点
    int keyCount;             // 当前关键字数量
    
    // 构造函数
    BTreeNode(bool isLeaf = true) : leaf(isLeaf), keyCount(0) {
        keys.resize(M - 1);   // 最多M-1个关键字
        children.resize(M);   // 最多M个子节点
    }
    
    // 析构函数
    ~BTreeNode() {
        for (int i = 0; i < children.size(); i++) {
            if (children[i] != nullptr) {
                delete children[i];
            }
        }
    }
    
    // 在节点中查找关键字位置
    int findKey(const T& key) const {
        int idx = 0;
        while (idx < keyCount && keys[idx] < key) {
            idx++;
        }
        return idx;
    }
    
    // 插入关键字到节点
    void insertKey(const T& key) {
        int i = keyCount - 1;
        
        // 找到插入位置并移动元素
        while (i >= 0 && keys[i] > key) {
            keys[i + 1] = keys[i];
            i--;
        }
        
        keys[i + 1] = key;
        keyCount++;
    }
    
    // 删除关键字
    void removeKey(int idx) {
        for (int i = idx + 1; i < keyCount; i++) {
            keys[i - 1] = keys[i];
        }
        keyCount--;
    }
    
    // 插入子节点
    void insertChild(BTreeNode* child, int idx) {
        for (int i = children.size() - 1; i > idx; i--) {
            children[i] = children[i - 1];
        }
        children[idx] = child;
    }
    
    // 删除子节点
    void removeChild(int idx) {
        for (int i = idx; i < children.size() - 1; i++) {
            children[i] = children[i + 1];
        }
        children[children.size() - 1] = nullptr;
    }
};
```



```c++
template <typename T, int M>
class BTree {
private:
    BTreeNode<T, M>* root;    // 根节点
    int t;                    // 最小度数 (t = ceil(M/2))

public:
    // 构造函数
    BTree() : root(nullptr) {
        t = (M + 1) / 2;      // 计算最小度数
    }
    
    // 析构函数
    ~BTree() {
        if (root != nullptr) {
            delete root;
        }
    }
    
    // 查找操作
    bool contains(const T& key) const {
        return search(root, key) != nullptr;
    }
    
    // 插入操作
    void insert(const T& key) {
        // 如果树为空
        if (root == nullptr) {
            root = new BTreeNode<T, M>(true);
            root->keys[0] = key;
            root->keyCount = 1;
        } else {
            // 如果根节点已满，需要分裂
            if (root->keyCount == M - 1) {
                BTreeNode<T, M>* newRoot = new BTreeNode<T, M>(false);
                newRoot->children[0] = root;
                splitChild(newRoot, 0);
                root = newRoot;
            }
            insertNonFull(root, key);
        }
    }
    
    // 删除操作
    void remove(const T& key) {
        if (root == nullptr) {
            return;
        }
        
        remove(root, key);
        
        // 如果根节点没有关键字了
        if (root->keyCount == 0) {
            BTreeNode<T, M>* oldRoot = root;
            if (root->leaf) {
                root = nullptr;
            } else {
                root = root->children[0];
            }
            delete oldRoot;
        }
    }
    
    // 打印树
    void printTree() const {
        if (root != nullptr) {
            printTree(root, 0);
        } else {
            cout << "空树" << endl;
        }
    }
    
    // 中序遍历
    void inorderTraversal() const {
        inorderTraversal(root);
        cout << endl;
    }

private:
    // 查找关键字
    BTreeNode<T, M>* search(BTreeNode<T, M>* node, const T& key) const;
    
    // 插入相关方法
    void insertNonFull(BTreeNode<T, M>* node, const T& key);
    void splitChild(BTreeNode<T, M>* parent, int idx);
    
    // 删除相关方法
    void remove(BTreeNode<T, M>* node, const T& key);
    void removeFromLeaf(BTreeNode<T, M>* node, int idx);
    void removeFromNonLeaf(BTreeNode<T, M>* node, int idx);
    T getPredecessor(BTreeNode<T, M>* node, int idx);
    T getSuccessor(BTreeNode<T, M>* node, int idx);
    void fill(BTreeNode<T, M>* node, int idx);
    void borrowFromPrev(BTreeNode<T, M>* node, int idx);
    void borrowFromNext(BTreeNode<T, M>* node, int idx);
    void merge(BTreeNode<T, M>* node, int idx);
    
    // 工具方法
    void printTree(BTreeNode<T, M>* node, int level) const;
    void inorderTraversal(BTreeNode<T, M>* node) const;
    int findKeyIndex(BTreeNode<T, M>* node, const T& key) const;
};
```



```c++
// 查找关键字
template <typename T, int M>
BTreeNode<T, M>* BTree<T, M>::search(BTreeNode<T, M>* node, const T& key) const {
    if (node == nullptr) return nullptr;
    
    int i = 0;
    while (i < node->keyCount && key > node->keys[i]) {
        i++;
    }
    
    if (i < node->keyCount && key == node->keys[i]) {
        return node;
    }
    
    if (node->leaf) {
        return nullptr;
    }
    
    return search(node->children[i], key);
}

// 向非满节点插入
template <typename T, int M>
void BTree<T, M>::insertNonFull(BTreeNode<T, M>* node, const T& key) {
    int i = node->keyCount - 1;
    
    if (node->leaf) {
        // 叶子节点：直接插入
        while (i >= 0 && node->keys[i] > key) {
            node->keys[i + 1] = node->keys[i];
            i--;
        }
        node->keys[i + 1] = key;
        node->keyCount++;
    } else {
        // 内部节点：找到要插入的子节点
        while (i >= 0 && node->keys[i] > key) {
            i--;
        }
        i++;
        
        // 如果子节点已满，需要分裂
        if (node->children[i]->keyCount == M - 1) {
            splitChild(node, i);
            if (key > node->keys[i]) {
                i++;
            }
        }
        insertNonFull(node->children[i], key);
    }
}

// 分裂子节点
template <typename T, int M>
void BTree<T, M>::splitChild(BTreeNode<T, M>* parent, int idx) {
    BTreeNode<T, M>* fullChild = parent->children[idx];
    BTreeNode<T, M>* newChild = new BTreeNode<T, M>(fullChild->leaf);
    
    // 新节点获取后半部分关键字
    for (int j = 0; j < t - 1; j++) {
        newChild->keys[j] = fullChild->keys[j + t];
    }
    newChild->keyCount = t - 1;
    
    // 如果不是叶子节点，复制子节点指针
    if (!fullChild->leaf) {
        for (int j = 0; j < t; j++) {
            newChild->children[j] = fullChild->children[j + t];
        }
    }
    fullChild->keyCount = t - 1;
    
    // 在父节点中为新孩子腾出空间
    for (int j = parent->keyCount; j > idx; j--) {
        parent->keys[j] = parent->keys[j - 1];
    }
    for (int j = parent->keyCount + 1; j > idx + 1; j--) {
        parent->children[j] = parent->children[j - 1];
    }
    
    // 将中间关键字提升到父节点
    parent->keys[idx] = fullChild->keys[t - 1];
    parent->children[idx + 1] = newChild;
    parent->keyCount++;
}
```



```c++
// 删除关键字
template <typename T, int M>
void BTree<T, M>::remove(BTreeNode<T, M>* node, const T& key) {
    int idx = findKeyIndex(node, key);
    
    if (idx < node->keyCount && node->keys[idx] == key) {
        // 关键字在当前节点中
        if (node->leaf) {
            removeFromLeaf(node, idx);
        } else {
            removeFromNonLeaf(node, idx);
        }
    } else {
        // 关键字不在当前节点中
        if (node->leaf) {
            return; // 关键字不存在
        }
        
        bool isLastChild = (idx == node->keyCount);
        
        // 如果子节点关键字数不足，需要填充
        if (node->children[idx]->keyCount < t) {
            fill(node, idx);
        }
        
        // 决定从哪个子节点继续删除
        if (isLastChild && idx > node->keyCount) {
            remove(node->children[idx - 1], key);
        } else {
            remove(node->children[idx], key);
        }
    }
}

// 从叶子节点删除
template <typename T, int M>
void BTree<T, M>::removeFromLeaf(BTreeNode<T, M>* node, int idx) {
    for (int i = idx + 1; i < node->keyCount; i++) {
        node->keys[i - 1] = node->keys[i];
    }
    node->keyCount--;
}

// 从内部节点删除
template <typename T, int M>
void BTree<T, M>::removeFromNonLeaf(BTreeNode<T, M>* node, int idx) {
    T key = node->keys[idx];
    
    // 如果前驱子节点有足够的关键字
    if (node->children[idx]->keyCount >= t) {
        T pred = getPredecessor(node, idx);
        node->keys[idx] = pred;
        remove(node->children[idx], pred);
    }
    // 如果后继子节点有足够的关键字
    else if (node->children[idx + 1]->keyCount >= t) {
        T succ = getSuccessor(node, idx);
        node->keys[idx] = succ;
        remove(node->children[idx + 1], succ);
    }
    // 合并两个子节点
    else {
        merge(node, idx);
        remove(node->children[idx], key);
    }
}

// 获取前驱
template <typename T, int M>
T BTree<T, M>::getPredecessor(BTreeNode<T, M>* node, int idx) {
    BTreeNode<T, M>* current = node->children[idx];
    while (!current->leaf) {
        current = current->children[current->keyCount];
    }
    return current->keys[current->keyCount - 1];
}

// 获取后继
template <typename T, int M>
T BTree<T, M>::getSuccessor(BTreeNode<T, M>* node, int idx) {
    BTreeNode<T, M>* current = node->children[idx + 1];
    while (!current->leaf) {
        current = current->children[0];
    }
    return current->keys[0];
}

// 填充不足的子节点
template <typename T, int M>
void BTree<T, M>::fill(BTreeNode<T, M>* node, int idx) {
    // 从前一个兄弟借
    if (idx != 0 && node->children[idx - 1]->keyCount >= t) {
        borrowFromPrev(node, idx);
    }
    // 从后一个兄弟借
    else if (idx != node->keyCount && node->children[idx + 1]->keyCount >= t) {
        borrowFromNext(node, idx);
    }
    // 合并兄弟节点
    else {
        if (idx != node->keyCount) {
            merge(node, idx);
        } else {
            merge(node, idx - 1);
        }
    }
}

// 从前一个兄弟借关键字
template <typename T, int M>
void BTree<T, M>::borrowFromPrev(BTreeNode<T, M>* node, int idx) {
    BTreeNode<T, M>* child = node->children[idx];
    BTreeNode<T, M>* sibling = node->children[idx - 1];
    
    // 为借来的关键字腾出空间
    for (int i = child->keyCount - 1; i >= 0; i--) {
        child->keys[i + 1] = child->keys[i];
    }
    
    if (!child->leaf) {
        for (int i = child->keyCount; i >= 0; i--) {
            child->children[i + 1] = child->children[i];
        }
    }
    
    // 移动父节点的关键字下来
    child->keys[0] = node->keys[idx - 1];
    
    if (!child->leaf) {
        child->children[0] = sibling->children[sibling->keyCount];
    }
    
    // 移动兄弟节点的关键字到父节点
    node->keys[idx - 1] = sibling->keys[sibling->keyCount - 1];
    
    child->keyCount++;
    sibling->keyCount--;
}

// 从后一个兄弟借关键字
template <typename T, int M>
void BTree<T, M>::borrowFromNext(BTreeNode<T, M>* node, int idx) {
    BTreeNode<T, M>* child = node->children[idx];
    BTreeNode<T, M>* sibling = node->children[idx + 1];
    
    // 移动父节点的关键字下来
    child->keys[child->keyCount] = node->keys[idx];
    
    if (!child->leaf) {
        child->children[child->keyCount + 1] = sibling->children[0];
    }
    
    // 移动兄弟节点的关键字到父节点
    node->keys[idx] = sibling->keys[0];
    
    // 调整兄弟节点
    for (int i = 1; i < sibling->keyCount; i++) {
        sibling->keys[i - 1] = sibling->keys[i];
    }
    
    if (!sibling->leaf) {
        for (int i = 1; i <= sibling->keyCount; i++) {
            sibling->children[i - 1] = sibling->children[i];
        }
    }
    
    child->keyCount++;
    sibling->keyCount--;
}

// 合并节点
template <typename T, int M>
void BTree<T, M>::merge(BTreeNode<T, M>* node, int idx) {
    BTreeNode<T, M>* child = node->children[idx];
    BTreeNode<T, M>* sibling = node->children[idx + 1];
    
    // 将父节点的关键字移到子节点
    child->keys[t - 1] = node->keys[idx];
    
    // 复制兄弟节点的关键字
    for (int i = 0; i < sibling->keyCount; i++) {
        child->keys[i + t] = sibling->keys[i];
    }
    
    // 复制兄弟节点的子节点
    if (!child->leaf) {
        for (int i = 0; i <= sibling->keyCount; i++) {
            child->children[i + t] = sibling->children[i];
        }
    }
    
    // 调整父节点
    for (int i = idx + 1; i < node->keyCount; i++) {
        node->keys[i - 1] = node->keys[i];
    }
    for (int i = idx + 2; i <= node->keyCount; i++) {
        node->children[i - 1] = node->children[i];
    }
    
    child->keyCount += sibling->keyCount + 1;
    node->keyCount--;
    
    // 释放兄弟节点
    sibling->children.clear();
    delete sibling;
}
```



```c++
// 查找关键字索引
template <typename T, int M>
int BTree<T, M>::findKeyIndex(BTreeNode<T, M>* node, const T& key) const {
    int idx = 0;
    while (idx < node->keyCount && node->keys[idx] < key) {
        idx++;
    }
    return idx;
}

// 打印树
template <typename T, int M>
void BTree<T, M>::printTree(BTreeNode<T, M>* node, int level) const {
    if (node == nullptr) return;
    
    cout << "Level " << level << ": ";
    for (int i = 0; i < node->keyCount; i++) {
        cout << node->keys[i] << " ";
    }
    cout << endl;
    
    if (!node->leaf) {
        for (int i = 0; i <= node->keyCount; i++) {
            printTree(node->children[i], level + 1);
        }
    }
}

// 中序遍历
template <typename T, int M>
void BTree<T, M>::inorderTraversal(BTreeNode<T, M>* node) const {
    if (node == nullptr) return;
    
    int i;
    for (i = 0; i < node->keyCount; i++) {
        if (!node->leaf) {
            inorderTraversal(node->children[i]);
        }
        cout << node->keys[i] << " ";
    }
    
    if (!node->leaf) {
        inorderTraversal(node->children[i]);
    }
}
```

